name: PSGallery Latest Release

on:
  workflow_dispatch:

jobs:
  psgalleryDeploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 #Ensure we are getting all the tag history

      - name: Get latest release details
        id: get_release
        env:
          GH_TOKEN: ${{ github.token }}
        shell: pwsh
        run: |
          $verbosePreference = 'Continue'
          $release = gh release view --json tagName,name,body,createdAt,author,assets,isPrerelease
          write-verbose "Release:`n$($release|out-string)"
          $releaseFromJson = $release|convertFrom-json -errorAction ignore
          $tagName = $releaseFromJson.tagName
          $releaseName = $releaseFromJson.name
          $isPreRelease = $releaseFromJson.isPrerelease
          write-verbose "tagName: $($tagName) releaseName: $($releaseName) isPreRelease: $($isPreRelease)"
          Write-Output "tag_name=$tagName" >> $env:GITHUB_OUTPUT
          Write-Output "release_name=$releaseName" >> $env:GITHUB_OUTPUT
          Write-Output "release_isPreRelease=$isPreRelease" >> $env:GITHUB_OUTPUT

      - name: Install dependencies
        shell: pwsh
        run: |
          $VerbosePreference = 'Continue'
          Install-Module -Name Microsoft.PowerShell.PSResourceGet -Force -SkipPublisherCheck
          $moduleList = @('Microsoft.PowerShell.PSResourceGet')
          import-module $moduleList
          get-module $moduleList|Select-object Name,@{name='version';expression={if($_.PrivateData.PSData.Prerelease){"$($_.Version)-$($_.PrivateData.PSData.Prerelease)"}else{"$($_.Version)"}}}|Format-Table

      - name: Register Repository
        shell: pwsh
        id: repoSetup
        if: success()  
        run: |
          $VerbosePreference = 'Continue'
          $repoUrl = "https://nuget.pkg.github.com/$($env:GITHUB_REPOSITORY_OWNER)/index.json"
          write-verbose "Got repoUrl: $repoUrl"
          $repositorySplat = @{
            uri = $repoUrl
            trusted = $true
            name = 'myGHPackages'
          }
          register-psresourcerepository @repositorySplat
          write-verbose "Repositories:`n $(get-psresourceRepository|select name,uri,trusted|format-list|out-string)"

      - name: Install Latest Module And Publish to Gallery
        shell: pwsh
        id: moduleInstall
        env:
          GH_TOKEN: ${{ github.token }}
          PSGalleryToken: ${{ secrets.PSGALLERY }}
          isPreRelease: ${{ steps.get_release.outputs.release_isPreRelease }}
          tagName: ${{ steps.get_release.outputs.tag_name }}
        if: success()  
        run: |
          $VerbosePreference = 'Continue'
          $isPreRelease = $env:isPreRelease
          if(!(test-path .\moduleForgeConfig.xml)){
            throw 'Error reading ModuleForge Config'
          }
          $config = import-clixml .\moduleForgeConfig.xml
          $moduleName = $config.moduleName
          write-verbose "ModuleName: $moduleName"
          $credential = New-Object System.Management.Automation.PSCredential("githubActions", (ConvertTo-SecureString $env:GH_TOKEN -AsPlainText -Force))
          $versionString = $env:tagName
          write-verbose "Version from Tag: $versionString"
          $version = $versionString.substring(1)
          $semver = [semver]::New($version)
          write-verbose "VersionConvert : $semver"
          $fetchSplat = @{
            Repository = 'myGHPackages'
            name = $moduleName
            credential = $credential
            version = $semver
          }
          $latestRelease = find-psresource @fetchSplat
          write-verbose "latestRelease: $($latestRelease|format-list|out-string)"
          if($latestRelease)
          {
            #$latestRelease|install-psresource -credential $credential
            install-psresource @fetchSplat
          }else{
            write-warning 'No module found'
          }
          #Need to handle case insensitive
          #Need to ALSO handle the lowercase gh packages/psResource bug

          $allModules = $(Get-Module -ListAvailable)
          write-verbose "All Found Modules:`n$($allModules|format-table|out-string)"
          write-verbose "Checking for $moduleName installation"
          $moduleFound = $(Get-Module -ListAvailable).where{
            $_.Name -ieq $moduleName
          }

          if($moduleFound)
          {
            write-verbose "ModuleFound:`n$($moduleFound|out-string)"
          }else{
            write-verbose 'Checking for, and correcting, PowerShellGet+GHPackages casing shenanegans'
            $modulePathContents = Get-ChildItem /home/runner/.local/share/powershell/Modules
            write-verbose "/home/runner/.local/share/powershell/Modules Contents:`n$($modulePathContents|Format-List|Out-String)"
            $moduleFolderContents = $modulePathContents.where{$_.name -ieq $moduleName}
            if($moduleFolderContents)
            {
                $fName = $moduleFolderContents.fullname
                $fullFolderContents = Get-ChildItem $fName -recurse
                #write-verbose "$fName Contents:`n$($fullFolderContents|Format-List|Out-String)"
                $modManifest = $($fullFolderContents).where{$_.Name -like '*.psd1'}|Select-Object -first 1
                if($modManifest){
                    write-verbose "Module Manifest found at $($modManifest.fullname)"
                    $moduleBaseFolder = Get-Item $moduleFolderContents.FullName
                    write-verbose "Compare folder and manifest basenames: folderName: $($moduleBaseFolder.Basename) vs manifestName: $($modManifest.BaseName)"
                    if($moduleBaseFolder.Basename -cne $modManifest.BaseName)
                    {
                        write-verbose "Attempt to rename folder to manifest basename to correct for casing"
                        try{
                            Rename-Item -path $moduleBaseFolder.FullName -NewName $modManifest.BaseName -Force -Erroraction Stop
                        }catch{
                            throw 'Error renaming folder'
                        }
                        #Just in case the file io needs time to catch up
                        for ($i=0; $i -lt 5; $i++) {
                            $moduleFound = Get-Module -ListAvailable | Where-Object { $_.Name -ieq $moduleName }
                            if ($moduleFound) { break }
                            Start-Sleep -Seconds 1
                        }
                    }else{
                        write-verbose 'names already match'
                    }
                }else{
                    throw 'Manifest not found, module install must have failed'
                }
            }else{
                throw "Module $moduleName not found at /home/runner/.local/share/powershell/Modules. Indicating failed install"
            }
            #Final Check
            if(!$moduleFound)
            {
                $allModules = $(Get-Module -ListAvailable)
                write-verbose "All Found Modules:`n$($allModules|format-table|out-string)"
                throw 'Module failed install'
            }
          }
          write-verbose 'Push Package to PSGallery'
          $publishSplat = @{
            repository = 'PSGallery'
            APIKey = $env:PSGalleryToken
            Path = $moduleFound.moduleBase
          }
          if(-not (Test-Path $publishSplat.Path))
          {
            throw "Publish Reference Path does not exist: $($moduleFound.moduleBase) "
          }else{
            write-verbose "Publishing $moduleName version $semver to PSGallery from $($publishSplat.Path)"
            publish-psResource @publishSplat
          }
          